# API Specification: Uniswap v4 Privacy Hook Adapter

## Overview

This document describes the API contracts and interfaces for the Uniswap v4 Privacy Hook Adapter, which enables privacy-preserving liquidity addition through ZK-proof validation.

## Interface Files

### 1. IPrivacyLiquidityHook.sol

**Location:** `contracts/IPrivacyLiquidityHook.sol`

**Purpose:** Main interface for the privacy-preserving liquidity hook

**Key Functions:**

#### computeActionHash
```solidity
function computeActionHash(
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    address recipient
) external pure returns (bytes32 actionHash);
```

**Parameters:**
- `key` (PoolKey): Pool identifier containing currency0, currency1, fee, tickSpacing, hooks
- `params` (ModifyLiquidityParams): Liquidity parameters including tick bounds and delta
- `recipient` (address): Address receiving the liquidity position

**Returns:**
- `actionHash` (bytes32): keccak256 hash of all parameters for ZK-proof alignment

**Usage:**
- Called by users to generate the action hash needed for Noir circuit proof generation
- Must match the public inputs used in the ZK-proof

#### addLiquidityWithPrivacy
```solidity
function addLiquidityWithPrivacy(
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata proof,
    bytes32[] calldata publicInputs
) external;
```

**Parameters:**
- `key` (PoolKey): Target Uniswap v4 pool
- `params` (ModifyLiquidityParams): Liquidity addition parameters
- `proof` (bytes): ZK-proof generated by Noir circuit
- `publicInputs` (bytes32[]): Public inputs array for proof verification

**Access Control:**
- Only callable by the authorized PrivacyVault contract
- Reverts with `OnlyPrivacyVault()` if caller is not vault

**Flow:**
1. Validates caller is PrivacyVault
2. Calls PoolManager.modifyLiquidity
3. Hook callback validates transient storage authorization
4. Assets settle from Vault to PoolManager

#### beforeAddLiquidity
```solidity
function beforeAddLiquidity(
    address sender,
    PoolKey calldata key,
    IPoolManager.ModifyLiquidityParams calldata params,
    bytes calldata hookData
) external returns (bytes4);
```

**Parameters:**
- `sender` (address): Address initiating the operation
- `key` (PoolKey): Pool being modified
- `params` (ModifyLiquidityParams): Liquidity parameters
- `hookData` (bytes): Additional data (unused in this implementation)

**Returns:**
- Selector confirming hook execution: `bytes4(keccak256("beforeAddLiquidity(address,(address,address,uint24,int24,address),(int24,int24,int128,bytes32),bytes)"))`

**Access Control:**
- Only callable by the PoolManager
- Reverts with `OnlyPoolManager()` if caller is not PoolManager

**Validation:**
- Reads transient storage slot for authorization
- Validates authorization was set by PrivacyVault
- Reverts with `UnauthorizedLiquidityAddition()` if not authorized

## Events

### PrivacyLiquidityAdded
```solidity
event PrivacyLiquidityAdded(
    bytes32 indexed poolId,
    address indexed recipient,
    int128 liquidityDelta,
    bytes32 actionHash
);
```

**Emitted When:**
- Privacy-preserving liquidity addition completes successfully

**Parameters:**
- `poolId`: Unique identifier for the pool
- `recipient`: Address receiving the liquidity position
- `liquidityDelta`: Amount of liquidity added
- `actionHash`: Hash of the action parameters

## Errors

### UnauthorizedLiquidityAddition
```solidity
error UnauthorizedLiquidityAddition();
```

**Thrown When:**
- Hook callback detects invalid or missing transient storage authorization
- ZK-proof was not validated in the same transaction

### OnlyPrivacyVault
```solidity
error OnlyPrivacyVault();
```

**Thrown When:**
- addLiquidityWithPrivacy is called by an address other than the authorized PrivacyVault

### OnlyPoolManager
```solidity
error OnlyPoolManager();
```

**Thrown When:**
- Hook callbacks are called by an address other than the PoolManager

### InvalidPoolParameters
```solidity
error InvalidPoolParameters();
```

**Thrown When:**
- Pool key parameters are invalid (e.g., currency0 >= currency1)
- Tick parameters are invalid

### InvalidLiquidityDelta
```solidity
error InvalidLiquidityDelta();
```

**Thrown When:**
- liquidityDelta is not positive (must be adding liquidity, not removing)

## External Dependencies

### Uniswap v4 Core

**IPoolManager:**
```solidity
interface IPoolManager {
    function modifyLiquidity(
        PoolKey memory key,
        ModifyLiquidityParams memory params,
        bytes calldata hookData
    ) external returns (BalanceDelta delta, BalanceDelta feesAccrued);
    
    function settle(Currency currency) external returns (uint256 paid);
}
```

**PoolKey:**
```solidity
struct PoolKey {
    Currency currency0;
    Currency currency1;
    uint24 fee;
    int24 tickSpacing;
    IHooks hooks;
}
```

**ModifyLiquidityParams:**
```solidity
struct ModifyLiquidityParams {
    int24 tickLower;
    int24 tickUpper;
    int128 liquidityDelta;
    bytes32 salt;
}
```

### PrivacyVault Integration (001)

**Expected Interface:**
```solidity
interface IPrivacyVault {
    function executeAction(
        bytes32 actionHash,
        bytes calldata proof,
        bytes calldata data
    ) external;
}
```

**Integration Flow:**
1. User generates ZK-proof off-chain using Noir circuit
2. User calls PrivacyVault.executeAction with actionHash and proof
3. PrivacyVault validates proof and sets transient authorization
4. PrivacyVault calls Hook.addLiquidityWithPrivacy
5. Hook executes liquidity addition with privacy preserved

## Data Structures

### Transient Authorization Layout

**Storage Slot:** `keccak256("ghostroute.privacy.authorized")`

**Data Format:**
```
Slot 0: address authorizedRecipient (20 bytes, left-aligned)
```

**Usage:**
- Set by PrivacyVault before calling Hook
- Read by Hook in beforeAddLiquidity callback
- Automatically cleared at transaction end (EIP-1153)

### ActionHash Encoding

**Components (in order):**
1. `key.currency0` (address) - 20 bytes
2. `key.currency1` (address) - 20 bytes
3. `key.fee` (uint24) - 3 bytes
4. `key.tickSpacing` (int24) - 3 bytes
5. `params.tickLower` (int24) - 3 bytes
6. `params.tickUpper` (int24) - 3 bytes
7. `params.liquidityDelta` (int128) - 16 bytes
8. `params.salt` (bytes32) - 32 bytes
9. `recipient` (address) - 20 bytes

**Hash Function:** `keccak256(abi.encode(...components))`

**Alignment:**
- Noir circuit must use identical encoding
- Public inputs to circuit must match Solidity's encoding exactly

## Access Control Matrix

| Function | Allowed Callers | Validation |
|----------|----------------|------------|
| constructor | Deployer | Sets immutable addresses |
| computeActionHash | Anyone | Pure function, no state |
| addLiquidityWithPrivacy | PrivacyVault only | msg.sender == PRIVACY_VAULT |
| beforeAddLiquidity | PoolManager only | msg.sender == poolManager |
| _beforeAddLiquidity (internal) | N/A | Only via PoolManager callback |

## Version Compatibility

**Solidity Version:** ^0.8.24 (required for EIP-1153 transient storage opcodes)

**Uniswap v4 Versions:**
- v4-core: Latest main
- v4-periphery: Latest main

**Noir Version:** Compatible with Noir 1.0+ for circuit verification

## Gas Estimates

| Operation | Estimated Gas |
|-----------|---------------|
| computeActionHash | ~3,000 |
| addLiquidityWithPrivacy (total) | ~180,000 - 220,000 |
| beforeAddLiquidity callback | ~15,000 |
| Transient storage read/write | ~100 each |
| PoolManager.modifyLiquidity | ~150,000 |
| Asset settlement | ~20,000 |

**Total Target:** <200,000 gas per privacy liquidity addition

## Security Considerations

1. **No Persistent State:** Hook must not store any user-specific data
2. **Transient Only:** All authorization must use EIP-1153 transient storage
3. **Atomic Operations:** All operations must complete or revert together
4. **No Reentrancy:** Hook callbacks protected by onlyPoolManager
5. **Proof Validation:** ZK-proofs validated by PrivacyVault before hook execution
