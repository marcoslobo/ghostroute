# API Contract: ERC20 Deposit & Withdraw Support

**Feature**: `014-erc20-deposit-withdraw`  
**Date**: 2026-02-06  
**Contract**: `PrivacyVault.sol`

---

## New Functions

### `depositERC20` — Simplified ERC20 Deposit (Testing/Development)

Deposits ERC20 tokens using standard `transferFrom` (requires prior approval to vault).

```solidity
/// @notice Simplified ERC20 deposit (for testing without Permit2)
/// @param token ERC20 token address (must not be address(0))
/// @param amount Amount of tokens to deposit
/// @param commitment H(nullifier, token, amount, salt)
/// @param nullifier Unique identifier preventing double-spend
/// @return leafIndex Position in Merkle tree
function depositERC20(
    address token,
    uint256 amount,
    bytes32 commitment,
    bytes32 nullifier
) external nonReentrant returns (uint256 leafIndex);
```

**Preconditions**:
- `IERC20(token).allowance(msg.sender, address(this)) >= amount`
- `allowedTokens[token] == true`
- `msg.value == 0` (no ETH sent)

**Effects**:
- `IERC20(token).safeTransferFrom(msg.sender, address(this), amount)`
- `nullifiers[nullifier] = true`
- `commitments[commitment] = true`
- `tokenBalances[token] += amount`
- `currentRoot = keccak256(currentRoot, commitment)`
- `nextLeafIndex++`

**Events emitted**:
- `Deposit(commitment, nullifier, token, amount, leafIndex, newRoot)`
- `MerkleRootUpdated(oldRoot, newRoot, leafCount)`

**Errors**:
- `InvalidToken()` — token is `address(0)`
- `TokenNotAllowed(address token)` — token not in allowlist
- `InvalidCommitment()` — commitment is `bytes32(0)`
- `NullifierAlreadyUsed(bytes32 nullifier)` — nullifier already spent
- `InvalidTokenAmount()` — amount is 0
- `TreeAtCapacity()` — tree has 2^20 leaves
- `ETHSentForERC20()` — `msg.value > 0`

**Gas target**: < 150,000 gas

---

### `withdrawERC20` — ZK-Verified ERC20 Withdrawal

Withdraws ERC20 tokens using a ZK proof. Follows the UTXO Spend+Change model.

```solidity
/// @notice Withdraw ERC20 tokens using ZK proof (Spend + Change)
/// @param proof ZK proof data generated by Noir circuit
/// @param root Merkle tree root at time of proof generation
/// @param nullifierHash Public nullifier hash (prevents double-spending)
/// @param changeCommitment Commitment to the change note (UTXO)
/// @param actionHash Pedersen hash of (recipient, token, amount) — verified by circuit
/// @param token ERC20 token address to withdraw
/// @param recipient Address to receive the tokens
/// @param amount Amount of tokens to transfer
function withdrawERC20(
    bytes calldata proof,
    bytes32 root,
    bytes32 nullifierHash,
    bytes32 changeCommitment,
    bytes32 actionHash,
    address token,
    address recipient,
    uint256 amount
) external nonReentrant;
```

**Preconditions**:
- `tokenBalances[token] >= amount`
- `allowedTokens[token] == true`
- `nullifiers[nullifierHash] == false`
- `root == currentRoot`
- ZK proof verifies successfully

**Effects**:
- `nullifiers[nullifierHash] = true`
- `commitments[changeCommitment] = true`
- `tokenBalances[token] -= amount`
- `currentRoot = keccak256(currentRoot, changeCommitment)`
- `nextLeafIndex++`
- `IERC20(token).safeTransfer(recipient, amount)`

**Events emitted**:
- `AnonymousERC20Withdrawal(nullifierHash, token, recipient, amount, changeCommitment, changeIndex)`
- `MerkleRootUpdated(oldRoot, newRoot, leafCount)`

**Errors**:
- `InvalidAmount()` — amount is 0
- `InvalidToken()` — token is `address(0)` (use `withdraw()` for ETH)
- `TokenNotAllowed(address token)` — token not in allowlist
- `InsufficientTokenBalance(address token, uint256 available, uint256 requested)` — vault doesn't hold enough
- `ZKProofFailed()` — proof verification failed
- `NullifierAlreadySpent(bytes32 nullifier)` — double-spend attempt
- `InvalidMerkleRoot()` — root doesn't match current state
- `InvalidChangeCommitment()` — change commitment is `bytes32(0)`

**Gas target**: < 250,000 gas

---

### `depositWithPermit` (Updated) — Production ERC20 Deposit via Permit2

Updates the existing stub to use `SignatureTransfer` with witness binding.

```solidity
/// @notice Deposits ERC20 tokens with Permit2 SignatureTransfer (production path)
/// @param permit Permit2 transfer parameters (token, amount, nonce, deadline)
/// @param signature EIP-712 signature over permit + deposit witness
/// @param commitment H(nullifier, token, amount, salt)
/// @param nullifier Unique identifier preventing double-spend
/// @return leafIndex Position in Merkle tree
function depositWithPermit(
    ISignatureTransfer.PermitTransferFrom calldata permit,
    bytes calldata signature,
    bytes32 commitment,
    bytes32 nullifier
) external nonReentrant returns (uint256 leafIndex);
```

**Note**: This replaces the existing `depositWithPermit` signature. The old signature with `PermitSingle` is removed since it was never functional for ERC20.

**Preconditions**:
- `IERC20(permit.permitted.token).allowance(msg.sender, PERMIT2) >= permit.permitted.amount`
- `allowedTokens[permit.permitted.token] == true`

**Effects**:
- Permit2 verifies signature + witness and transfers tokens atomically
- `nullifiers[nullifier] = true`
- `commitments[commitment] = true`
- `tokenBalances[permit.permitted.token] += permit.permitted.amount`
- `currentRoot = keccak256(currentRoot, commitment)`
- `nextLeafIndex++`

**Gas target**: < 200,000 gas

---

## New Admin Functions

### `addAllowedToken` — Add Token to Allowlist

```solidity
/// @notice Add an ERC20 token to the allowlist
/// @param token Token address to allow
function addAllowedToken(address token) external onlyOwner;
```

**Effects**: `allowedTokens[token] = true`  
**Events**: `TokenAllowed(address indexed token)`

### `removeAllowedToken` — Remove Token from Allowlist

```solidity
/// @notice Remove an ERC20 token from the allowlist
/// @dev Does not affect existing deposits — users can still withdraw previously deposited tokens
/// @param token Token address to remove
function removeAllowedToken(address token) external onlyOwner;
```

**Effects**: `allowedTokens[token] = false`  
**Events**: `TokenRemoved(address indexed token)`

---

## New View Functions

### `getTokenBalance` — Query Internal Token Balance

```solidity
/// @notice Get the vault's internal balance for a specific token
/// @param token ERC20 token address
/// @return balance Internal tracked balance
function getTokenBalance(address token) external view returns (uint256 balance);
```

### `isTokenAllowed` — Check Token Allowlist Status

```solidity
/// @notice Check if a token is in the allowlist
/// @param token Token address to check
/// @return allowed Whether the token is allowed
function isTokenAllowed(address token) external view returns (bool allowed);
```

---

## New Events

```solidity
/// @notice Emitted when ERC20 tokens are withdrawn via ZK proof
event AnonymousERC20Withdrawal(
    bytes32 indexed nullifier,
    address indexed token,
    address indexed recipient,
    uint256 amount,
    bytes32 changeCommitment,
    uint256 changeIndex
);

/// @notice Emitted when a token is added to the allowlist
event TokenAllowed(address indexed token);

/// @notice Emitted when a token is removed from the allowlist
event TokenRemoved(address indexed token);
```

---

## New Custom Errors

```solidity
/// @notice Token address is address(0) — use ETH functions instead
error InvalidToken();

/// @notice Token not in the allowlist
error TokenNotAllowed(address token);

/// @notice Vault does not hold enough tokens for withdrawal
error InsufficientTokenBalance(address token, uint256 available, uint256 requested);

/// @notice ETH was sent with an ERC20 deposit call
error ETHSentForERC20();
```

---

## Existing Functions (Unchanged)

The following functions remain unchanged for backward compatibility:

| Function | Description |
|----------|-------------|
| `deposit(bytes32 commitment, bytes32 nullifier) payable` | Simplified ETH deposit |
| `withdraw(bytes proof, bytes32 root, bytes32 nullifierHash, bytes32 changeCommitment, address recipient, uint256 amount)` | ZK-verified ETH withdrawal |
| `executeAction(...)` | ZK-verified Uniswap v4 action |
| `computeActionHash(...)` | Action hash computation helper |
| `getMerkleRoot()` | Get current tree root |
| `verifyMerkleProof(...)` | Merkle proof verification (stub) |
| `getTreeInfo()` | Tree info (root, count, max, height) |
| `isNullifierUsed(bytes32)` | Nullifier status check |
| `getLeafCount()` | Total leaf count |
| `updateVerifier(address)` | Update ZK verifier (owner only) |
| `getOwner()` | Get owner address |

---

## Interface Updates

### IPrivacyVault (Extended)

```solidity
interface IPrivacyVault {
    // Existing functions (unchanged)
    function depositWithPermit(...) external payable returns (uint256);
    function getMerkleRoot() external view returns (bytes32);
    function verifyMerkleProof(...) external view returns (bool);
    function getTreeInfo() external view returns (bytes32, uint256, uint256, uint8);
    function isNullifierUsed(bytes32) external view returns (bool);
    function getLeafCount() external view returns (uint256);
    
    // New functions
    function depositERC20(address token, uint256 amount, bytes32 commitment, bytes32 nullifier) external returns (uint256);
    function withdrawERC20(bytes calldata proof, bytes32 root, bytes32 nullifierHash, bytes32 changeCommitment, bytes32 actionHash, address token, address recipient, uint256 amount) external;
    function getTokenBalance(address token) external view returns (uint256);
    function isTokenAllowed(address token) external view returns (bool);
}
```

---

## Constructor Changes

```solidity
constructor(address _verifier, address _permit2) {
    owner = msg.sender;
    verifier = IZKVerifier(_verifier);
    PERMIT2 = ISignatureTransfer(_permit2);
    currentRoot = bytes32(0);
}
```

**Breaking change**: Constructor now requires `_permit2` address. Deployment scripts must be updated.
